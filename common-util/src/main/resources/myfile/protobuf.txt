1.字节：byte：用来计量存储容量的一种计量单位；位：bit

2.一个字节等于8位  1byte = 8bit

char占用的是2个字节 16位，所以一个char类型的可以存储一个汉字。

整型：

byte:1个字节 8位 -128~127

short ：2个字节 16位 (-2^15~2^15-1)

int ：4个字节 32位 (-2^31~2^31-1)

long：8个字节 64位 (-2^63~2^63-1)

浮点型：

float：4个字节 32 位

double ：8个字节 64位

注：默认的是double类型，如3.14是double类型的，加后缀F（3.14F）则为float类型的。

char类型：

char：2个字节。

Boolean 类型:

boolean: （true or false）（并未指明是多少字节  1字节  1位 4字节）


16进制的每个字符需要用4位二进制位来表示，,0x0为0000,0xf为1111，即1个16进制数为4位，2个16进制数为8位，即一个字节。


*整体组成，2字节头+2字节数据长度+1字节命令字+n字节数据体+16字节MD5-16校验码
*数据长度=1字节命令字+数据体长度+16字节校验长度
*校验范围=头+长度+命令字+数据体

在序列化时，protobuf按照TLV的格式序列化每一个字段，T即Tag，也叫Key；V是该字段对应的值value；L是Value的长度，如果一个字段是整形，这个L部分会省略。

Key编码过后，该字节的第一个比特位表示之后的一个字节是否与当前这个字节有关:
如果第一个比特位为1，表示有关，即连续两个字节都是Key的编码；
如果第一个比特位为0，表示Key的编码只有当前一个字节，后面的字节是Length或者Value；


Value会根据数据类型的不同会有两种表现形式：
对于各种int,bool,enum类型，value就是Varint
对于string,bytes,message等等类型，value就是length+原始内容编码

Varints是一种紧凑表示数字的方法。它用一个或者多个字节表示一个数字，值越小的数字字节数越少。
相对于传统的用4字节表示int32类型数字，Varints对于小于128的数值都可以用一个字节表示，
大于128的数值会用更多的字节来表示，对于很大的数据则需要用5个字节来表示。

Varints算法描述： 每一个字节的最高位都是有特殊含义的，如果是1，则表示后续的字节也是该数字的一部分；如果是0，则结束
为1的时候，解析方式如下，先转换二进制，随后去掉首尾bit，再反转顺序，之后得到实际二进制。

key的定义：
(field_number >> 3) | wire_type
Key 由两部分组成。第一部分是 field_number，第二部分为 wire_type。表示 Value 的传输类型。也就是说，key中的后三位，是值的传输类型


9898
0099
01
0A05342E322E30120B30303030303231313738341A043031353622066962757330342A063333303130303064386440FF86B3F6054A2032303035323630373231333530303030303030303030323131373834303030335219535A4D30303030347C32303230303532363030327C307C31329201063130303030309801E6AAAEF605B2010430303032
32354445413042374644444333453446


00001010
00001010&111 = 2
10
0A 05 342E322E30 -> 4.2.0 -> version

00010010
00010010&111 = 2
18
12 0B 3030303030323131373834 -> 00000211784 -> posId

00011010
00011010&111 = 2
26
1A 04 30313536 -> 0156 -> busId

00100010
00100010&111  = 2
34
22 06 696275733034 -> ibus04 -> routeId

00101010
00101010&111 = 2
42
2A 06 333330313030 -> 330100 -> cityId

00110000
00110000&111 = 0
48
30 64 -> 100 -> ticketPrice

00111000
00111000&111 = 0
56
38 64 -> 100 -> cost

01000000
01000000&111 = 0
64
40 FF86B3F605 -> 1589795255 -> timeStamp

FF86B3F605解析如下：
11111111 10000110 10110011 11110110 00000101 // 二进制

1111111 0000110 0110011 1110110 00000101  // 去掉首部bit

00000101 1110110 0110011 0000110 1111111 // 反转顺序

1011110110011001100001101111111 // 得到十进制1589795255


01001010
01001010&111 = 2
74
4A 20 3230303532363037323133353030303030303030303032313137383430303033 -> 20052607213500000000 -> uniqueRecord

01010010
01010010&111 = 2
82
52 19 535A4D30303030347C32303230303532363030327C307C3132 -> SZM00004|20200526002|0|12 -> verifyArea

10010010 00000001 // 去掉首部bit
0010010 00000001 // 反转顺序
000000010010010  // 得到十进制146
10010010&111 = 2
146
9201 06 313030303030 -> 100000 -> driverId

10011000 00000001 // 去掉首部bit
0011000 00000001 // 反转顺序
000000010011000 // 得到十进制152
10011000&111 = 0
152
9801 E6AAAEF605 -> 1097476601349 -> attendanceTime

E6AAAEF605
11100110 10101010 10101110 11110110 00000101 // 二进制

1100110 0101010 0101110 1110110 00000101  // 去掉首部bit

00000101 1110110 0101110 0101010 1100110 // 反转顺序

1011110110010111001010101100110 // 得到十进制1590400358


10110010 00000001 // 去掉首部bit
0110010 00000001 // 反转顺序
000000010110010 // 得到十进制178
10110010&111 = 2
178
B201 04 30303032 -> 0002 -> fleetCode
